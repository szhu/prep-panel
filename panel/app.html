<html>
  <head>
    <meta charset="UTF-8" />
    <base target="_blank" />
    <title>Mac Prep Panel</title>
    <style>
      :root {
        user-select: none;
        color-scheme: light dark;
        font: 13px -apple-system;

        --text: #1a1a1a;
        --text-dim: gray;
        --background: #ececec;
        --fieldset-background: #e8e8e9;
        --border: #dbdbdb;
        --divider: #dbdbdb;
      }

      @media (prefers-color-scheme: dark) {
        :root {
          --background: #202020;
          --text-dim: gray;
          --fieldset-background: #222222;
          --border: #2f2f2f;
          --divider: #252525;
          --text: #d6d6d6;
        }
      }

      :root {
        background: var(--background);
        color: var(--text);
      }

      fieldset {
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 2px 12px;
        background: var(--fieldset-background);
        margin-bottom: 20px;
      }

      header {
        padding: 12px;
        font-weight: bold;

        position: sticky;
        z-index: 1;
        top: 0;
        background: var(--background);
      }

      table {
        /* margin: 0.5em 0; */
        font: inherit;
        border-collapse: separate;
      }
      td {
        padding: 0;
        height: 0.5em;
      }
      tr > td + td {
        border-left: 1em solid transparent;
      }

      button {
        font: inherit;
      }
      kbd {
        font: inherit;
      }

      [type="run-shell"] {
        display: none;
      }

      section {
        display: flex;
        gap: 0.3em;
      }

      fieldset p {
        margin: 0.5em 0;
      }

      fieldset > * + * {
        border-top: 2px solid var(--divider);
      }

      section:not([data-has-command]) > .checkbox > p > input[type="checkbox"] {
        visibility: hidden;
      }

      section:not([data-has-command]) > .contents > p:last-child::after {
        content: " (Not implemented)";
        color: var(--text-dim);
      }

      section:not([data-has-command]) {
        pointer-events: none;
      }

      h1 {
        padding: 0 12px;
      }

      a {
        color: initial;
      }

      input[type="checkbox"] {
        position: relative;
      }

      input[type="checkbox"][status]::after {
        content: attr(status);
        font-size: 0.9em;
        position: absolute;
        top: -10%;
        left: -10%;
        bottom: -10%;
        right: 0;
        line-height: 1.5;
      }

      .comment {
        opacity: 0.7;
        font-style: italic;
      }
    </style>
  </head>
  <body>
    <!-- <script src="https://unpkg.com/commonmark@0.30.0/dist/commonmark.js"></script> -->
    <script src="https://spec.commonmark.org/dingus/commonmark.js"></script>
    <script type="markdown" src="/content.md"></script>
    <script>
      // @ts-check
      let commonmark = /** @type {any} */ (window).commonmark;

      /**
       * Tell the server to run a shell command.
       */
      async function runShellCommand(command) {
        let response = await fetch("http://localhost:27370", {
          method: "POST",
          body: JSON.stringify({
            action: "RunCommandV1",
            shell: true,
            command,
          }),
        });
        let text = await response.text();
        return JSON.parse(text);
      }

      /**
       * Dedent each line to the indentation of the first line.
       */
      function dedent(s) {
        // debugger
        let lines = s.split("\n");
        if (lines[0].match(/^\s*$/)) {
          lines.shift();
        }
        let indentation = lines[0].match(/^\s*/)[0];

        return lines
          .map((line) => {
            if (line.slice(0, indentation.length) === indentation) {
              return line.slice(indentation.length);
            } else {
              return line;
            }
          })
          .join("\n");
      }

      document.addEventListener("click", async (e) => {
        if (!(e.target instanceof Element)) return;

        if (!e.target.matches(`button, input[type="checkbox"]`)) return;
        let buttonOrCheckbox = /** @type {HTMLInputElement} */ (e.target);
        e.preventDefault();

        let containerEl = buttonOrCheckbox.closest(`section`);
        if (containerEl == null) return;

        let el = /**@type {HTMLPreElement} */ (
          containerEl.querySelector(`[type="run-shell"]`)
        );
        if (el == null) return;

        let shellCommand = dedent(el.innerText);

        buttonOrCheckbox.setAttribute("status", "🔄");
        let result = await runShellCommand(shellCommand);

        if (result.code === 0) {
          buttonOrCheckbox.checked = true;
          buttonOrCheckbox.setAttribute("status", "✅");
        } else {
          buttonOrCheckbox.setAttribute("status", "❌");
        }
      });

      /**
       * Replace element with another, keeping all children.
       */
      function replaceWrapper(oldEl, newEl) {
        while (oldEl.childNodes.length > 0) {
          newEl.append(oldEl.childNodes[0]);
        }
        oldEl.insertAdjacentElement("afterend", newEl);
        oldEl.remove();
        return newEl;
      }

      /**
       * Wrap the children of an element with another element.
       */
      function lineEl(containerEl, linerEl) {
        while (containerEl.childNodes.length > 0) {
          linerEl.append(containerEl.childNodes[0]);
        }
        containerEl.append(linerEl);
        return linerEl;
      }

      /**
       * Replace element with its children.
       */
      function unwrapEl(el) {
        while (el.children.length > 0) {
          el.insertAdjacentElement("beforebegin", el.children[0]);
        }
        el.remove();
      }

      /**
       * Shorthand for creating an element.
       *
       * @param {string | {[key: string]: string}} tagOrAttributes
       * @param  {...(string | Node)} children
       */
      function El(tagOrAttributes, ...children) {
        let [tag, attributes] =
          typeof tagOrAttributes === "string"
            ? [tagOrAttributes, {}]
            : [tagOrAttributes.tag, tagOrAttributes];
        delete attributes.tag;

        let el = document.createElement(tag || "div");
        for (let key in attributes) {
          el.setAttribute(key, attributes[key]);
        }
        for (let child of children) {
          if (typeof child === "string") {
            child = document.createTextNode(child);
          }
          el.appendChild(child);
        }
        return el;
      }

      /**
       * Process a region of markdown text.
       */
      async function processMd(md) {
        let text;
        if (md.matches("[src]")) {
          let response = await fetch(md.getAttribute("src"));
          text = await response.text();
        } else {
          text = dedent(md.innerText);
        }

        // Render to markdown.
        var reader = new commonmark.Parser({ smart: true });
        var writer = new commonmark.HtmlRenderer();
        var parsed = reader.parse(text);
        var result = writer.render(parsed);
        let srcEl = document.createElement("body");
        srcEl.innerHTML = result;

        // Transform output HTML.
        let dstEl = document.createElement("body");
        {
          // Remove the <ul>/<ol> surrounding list items.
          for (let el of srcEl.querySelectorAll("ul, ol")) {
            unwrapEl(el);
          }

          for (let el of srcEl.querySelectorAll("li")) {
            // Replace <li> with <section>.
            el = replaceWrapper(el, document.createElement("section"));
            for (let child of [...el.childNodes]) {
              // Surround the list item contents with <p>.
              if (child instanceof Text && child.textContent.trim()) {
                el.append(El("p", child));
              } else {
                el.append(child);
              }
            }
          }

          // Add a checkbox to each <section> item.
          for (let section of srcEl.querySelectorAll("section")) {
            let sectionContents = lineEl(
              section,
              El({ tag: "div", class: "contents" })
            );

            // Add checkbox.
            sectionContents.insertAdjacentElement(
              "beforebegin",
              El(
                { tag: "div", class: "checkbox" },
                El("p", El({ tag: "input", type: "checkbox" }))
              )
            );
          }

          // If the list item has a <button>, remove the checkbox. (The user
          // will click the button instead of the checkbox.)
          for (let el of srcEl.querySelectorAll("section button")) {
            // el.type = "button";
            let section = el.closest("section");
            for (let checkbox of section.querySelectorAll("input")) {
              checkbox.remove();
            }
          }

          // Replace <h2> with <header>.
          for (let el of srcEl.querySelectorAll(":scope > h2")) {
            replaceWrapper(el, document.createElement("header"));
          }

          // Add "type" attribute to <pre> elements.
          for (let el of srcEl.querySelectorAll("pre")) {
            el.setAttribute("type", "run-shell");
            let section = el.closest("section");
            if (section != null) {
              section.setAttribute("data-has-command", "");
            }
          }

          // Pretty-print supported commands.
          for (let pre of srcEl.querySelectorAll("pre")) {
            let section = pre.closest("section");
            if (section == null) continue;

            let tbody;
            let table = El(
              "p",
              El({ tag: "table", cellspacing: "0" }, (tbody = El("tbody")))
            );

            for (let line of pre.innerText.split("\n")) {
              // Pretty-print commands that set a keyboard shortcut.
              {
                let m = line
                  .trim()
                  .match(
                    /^defaults write "\$?([^"]+)" "NSUserKeyEquivalents" -dict-add "([^"]+)" '?"([^"]+)"'?;$/
                  );
                if (m) {
                  let [, appId, menuPath, key] = m;

                  let appRepr = appId === "NSGlobalDomain" ? "Global" : appId;

                  let menuParts = menuPath.split("\\033").filter(Boolean);
                  let menuRepr = menuParts.join(" → ");

                  tbody.append(
                    El(
                      "tr",
                      El(
                        {
                          tag: "td",
                          class: appId === "NSGlobalDomain" ? "comment" : null,
                        },
                        appRepr
                      ),
                      El("td", menuRepr),
                      El(
                        "td",
                        El(
                          "kbd",
                          key.replace(/\\(.)/g, "$1").replace(/\\\\/g, "\\")
                        )
                      )
                    )
                  );
                  continue;
                }
              }

              // Pretty-print `brew install` commands.
              {
                let m = line
                  .trim()
                  .match(
                    /^brew install( --cask)? "?([^ "]+)"?( # ([^()]*)( \((.*)\))?)?$/
                  );
                if (m) {
                  let [, isCask, appId, , appName, , appComment] = m;
                  tbody.append(
                    El(
                      "tr",
                      El(
                        { tag: "td", colspan: "3" },
                        "Install ",
                        El(
                          {
                            tag: "a",
                            isCask,
                            href: isCask
                              ? `https://formulae.brew.sh/cask/${appId}`
                              : `https://formulae.brew.sh/formula/${appId}`,
                            target: "_blank",
                          },
                          appName ?? El("code", appId)
                        ),
                        appComment ? ` (${appComment})` : ""
                      )
                    )
                  );

                  continue;
                }
              }

              // Pretty-print comments.
              {
                let m = line.trim().match(/^## ?(.*)$/);
                if (m) {
                  tbody.append(
                    El("tr", El({ tag: "td", colspan: "3", class: "" }, m[1]))
                  );
                }

                continue;
              }
            }

            if (tbody.childElementCount > 0) {
              pre.insertAdjacentElement("beforebegin", table);
            }
          }

          // Replace modifier shorthands in <kbd> with their symbols.
          for (let el of srcEl.querySelectorAll("kbd")) {
            el.innerText = el.innerText
              .replace(/@/g, "⌘")
              .replace(/~/g, "⌥")
              .replace(/\$/g, "⇧")
              .replace(/\^/g, "⌃")
              .replace(/\bSpc\b/g, "⎵")
              .replace(/ /g, "⎵")
              .replace(/\\U21a9/g, "\u21a9")
              .toUpperCase();
          }

          // Add <fieldset> around sections delineated by <header>.
          while (srcEl.childElementCount > 0) {
            let el = srcEl.firstElementChild;
            el.remove();
            if (el.matches("header")) {
              dstEl.append(el);
              let fieldset = document.createElement("fieldset");
              dstEl.append(fieldset);
            } else {
              let fieldset = dstEl.querySelector(":scope > *:last-child");
              if (fieldset != null && fieldset.matches("fieldset")) {
                fieldset.append(el);
              } else {
                dstEl.append(el);
              }
            }
          }
        }

        // Insert into `md`.
        while (dstEl.childElementCount > 0) {
          md.insertAdjacentElement("afterend", dstEl.lastElementChild);
        }
      }

      for (let md of document.querySelectorAll(`[type=markdown]`)) {
        processMd(md);
      }
    </script>
  </body>
</html>
